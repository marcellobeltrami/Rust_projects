<h1>Rust theoretical concepts</h1>
<p>Rust bible: <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a></p>
<p>Rust by example: <a href="https://rust-exercises.com/01_intro/00_welcome">https://rust-exercises.com/01_intro/00_welcome</a></p>
<ul>
<li>
<p>Variable types explained</p>
<ul>
<li><em><strong>Primitive Types</strong>:</em>
<ul>
<li><strong>Integer Types</strong>: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>.
<ul>
<li>Represent whole numbers, both signed (<code>i</code>) and unsigned (<code>u</code>) with various bit sizes. Different bit size depends on how big your number is. Default is assigned to 32.</li>
</ul>
</li>
<li><strong>Floating-Point Types</strong>: <code>f32</code>, <code>f64</code>.
<ul>
<li>Represent numbers with fractional parts of different bit sizes.</li>
</ul>
</li>
<li><strong>Boolean Type</strong>: <code>bool</code>.
<ul>
<li>Represents true or false values.</li>
</ul>
</li>
<li><strong>Character Type</strong>: <code>char</code>.
<ul>
<li>Represents a Unicode scalar value. A Unicode scalar value is any value in the Unicode codespace; that is, the range of integers from 0 to 0x10FFFF.
a <code>char</code> is a 4-byte Unicode scalar value, which means it can represent characters from the entire Unicode range.</li>
</ul>
</li>
</ul>
</li>
<li><em><strong>Compound Types</strong>:</em>
<ul>
<li><strong>Arrays</strong>: <code>let arr: [i32; 5] = [1, 2, 3, 4, 5];</code>.
<ul>
<li><strong>Arrays</strong>: Fixed-size collections of items of the same type.</li>
</ul>
</li>
<li><strong>Tuples</strong>: <code>let tup: (i32, f64, char) = (500, 6.4, 'a');</code>.
<ul>
<li><strong>Tuples</strong>: Fixed-size collections of items of possibly different types.</li>
</ul>
</li>
</ul>
</li>
<li><em><strong>References</strong>:</em>
<ul>
<li><strong>Immutable References</strong>: <code>&amp;T</code>.
<ul>
<li><strong>Immutable References</strong>: Allow borrowing data without allowing modification.</li>
</ul>
</li>
<li><strong>Mutable References</strong>: <code>&amp;mut T</code>.
<ul>
<li><strong>Mutable References</strong>: Allow borrowing data for modification, but with restrictions on aliasing.</li>
</ul>
</li>
</ul>
</li>
<li><em><strong>Pointers</strong>:</em>
<ul>
<li><strong>Raw Pointers</strong>: <code>const T</code>, <code>mut T</code>.
<ul>
<li><strong>Raw Pointers</strong>: Unmanaged pointers, can be dereferenced but don't have ownership or borrowing semantics  (in concept close to C and Cpp pointers).</li>
</ul>
</li>
</ul>
</li>
<li><em><strong>Slices</strong>:</em>
<ul>
<li><strong>Slices for Arrays</strong>: <code>&amp;[T]</code>.
<ul>
<li><strong>Slices for Arrays</strong>: Provide a view into a contiguous sequence of elements in an array.</li>
</ul>
</li>
<li><strong>Slices for Dynamic Data</strong>: <code>&amp;str</code>.
<ul>
<li><strong>Slices for Dynamic Data</strong>: Represents a view into a UTF-8 encoded string.</li>
</ul>
</li>
</ul>
</li>
<li><em><strong>Ownership Types</strong>:</em>
<ul>
<li><strong>Owned Types</strong>: <code>String</code>, <code>Vec&lt;T&gt;</code>, <code>Box&lt;T&gt;</code>.
<ul>
<li><strong>Owned Types</strong>: Have unique ownership over their data, allowing mutation and deallocation. Meaning that they can be changed and size is variable.</li>
</ul>
</li>
<li><strong>Rc (Reference Counting)</strong>: <code>Rc&lt;T&gt;</code>.
<ul>
<li><strong>Rc (Reference Counting)</strong>: Allows multiple ownership with reference counting, but not for mutable data.</li>
</ul>
</li>
<li><strong>Arc (Atomic Reference Counting)</strong>: <code>Arc&lt;T&gt;</code>.
<ul>
<li><strong>Arc (Atomic Reference Counting)</strong>: Thread-safe version of <code>Rc</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Key and Borrowing + Borrow Checker</p>
<p><img src="Rust%20theoretical%20concepts%2023a2785fab994b4db7508c6c19feb291/Untitled.png" alt="Untitled" /></p>
<h3>Rules of Ownership</h3>
<p>Ownership is a set of rules that governs how a Rust program manages memory. The main rules are:</p>
<ol>
<li><strong>Each value in Rust has a variable that’s its owner.</strong></li>
<li><strong>There can only be one owner at a time.</strong></li>
<li><strong>When the owner goes out of scope, the value will be dropped.</strong></li>
</ol>
<h3>Rules of Borrowing:</h3>
<ol>
<li>At any given time, you can have either one mutable reference or any number of immutable references.
<ol>
<li><code>&amp;var</code>:  value is borrowed and cannot be modified.</li>
<li><code>&amp;mut var:</code> value can be modified</li>
</ol>
</li>
<li>References must always be valid.</li>
</ol>
<h3>Example of Ownership:</h3>
<pre><code class="language-rust">fn main() {
    let s1 = String::from("hello"); // s1 is the owner of the String
    let s2 = s1; // ownership of the String is moved to s2

    // s1 is no longer valid here
    println!("{}", s2); // this is valid
    // println!("{}", s1); // this would cause a compile-time error
} // s2 goes out of scope here and the String is dropped

</code></pre>
<p>In this example, <code>s1</code> owns the <code>String</code> initially. When <code>s1</code> is assigned to <code>s2</code>, <code>s1</code> loses ownership, and <code>s2</code> becomes the new owner. Rust enforces this rule at compile time, ensuring memory safety.</p>
<h3>Borrowing</h3>
<p>Borrowing allows you to reference a value without taking ownership of it. Borrowing comes in two flavors: immutable borrowing and mutable borrowing.</p>
<h3>Immutable Borrowing:</h3>
<p>You can have multiple immutable references to a value, but you cannot have a mutable reference while immutable references exist.</p>
<pre><code class="language-rust">fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1); // borrow s1 immutably

    println!("The length of '{}' is {}.", s1, len); // s1 is still valid here
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len() // use the borrowed value
} // s goes out of scope here, but because it doesn't own the value, nothing happens

</code></pre>
<h3>Mutable Borrowing:</h3>
<p>You can have only one mutable reference to a value at a time. This ensures that you cannot have data races at compile time.</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from("hello");

    change(&amp;mut s); // borrow s mutably

    println!("{}", s); // s is still valid here
}

fn change(s: &amp;mut String) {
    s.push_str(", world"); // modify the borrowed value
} // s goes out of scope here, but because it doesn't own the value, nothing happens

</code></pre>
</li>
<li>
<p>Integer overflow and saturation arithmetic</p>
<p>To deal with integer overflow there are two main ways. overflow-checks (a global option, see Profiles for more options) or using wrapping_/saturating_ methods.</p>
<p>❗<strong>Wrapping</strong>: If you think of all the possible values for a given integer type as a circle, wrapping around means that when you reach the maximum value, you start again from the minimum value.</p>
<p>❗<strong>Saturating:</strong> if integer operation overflows/underflows, the maximum or minimum value is returned.</p>
</li>
<li>
<p>Profiles: Dev and release</p>
<p>A <a href="https://doc.rust-lang.org/cargo/reference/profiles.html"><strong>profile</strong></a> is a set of configuration options that can be
used to customize the way Rust code is compiled.</p>
<p>Cargo provides two built-in profiles: <code>dev</code> and <code>release</code>.</p>
<p>The <code>dev</code> profile is used every time you run <code>cargo build</code>, <code>cargo run</code> or <code>cargo test</code>. It's aimed at local
development,
therefore it sacrifices runtime performance in favor of faster compilation times and a better debugging experience.</p>
<p>The <code>release</code> profile, instead, is optimized for runtime performance but incurs longer compilation times. You need
to explicitly request via the <code>--release</code> flag—e.g. <code>cargo build --release</code> or <code>cargo run --release</code>.</p>
<ul>
<li>
<p>Overflow checks</p>
<p>Overflow occurs when the resulting number in a operation is greated than the allocated primitive (eg. allocated u8, but the result would be expressed by a u32).</p>
<p>Rust lets you, the developer, choose which approach to use when an integer overflow occurs.
The behaviour is controlled by the <code>overflow-checks</code> profile setting.</p>
<p>If <code>overflow-checks</code> is set to <code>true</code>, Rust will <strong>panic at runtime</strong> when an integer operation overflows.
If <code>overflow-checks</code> is set to <code>false</code>, Rust will <strong>wrap around</strong> when an integer operation overflows. This will escalate the resulting integer to the correct primitive.</p>
<p><img src="Rust%20theoretical%20concepts%2023a2785fab994b4db7508c6c19feb291/Untitled%201.png" alt="example of a dev profile in Cargo.toml file." /></p>
<p>example of a dev profile in Cargo.toml file.</p>
<p>Here you can find more settings: <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">https://doc.rust-lang.org/cargo/reference/profiles.html</a></p>
</li>
</ul>
</li>
<li>
<p>Type casting (type conversion)</p>
<pre><code class="language-rust">let a: u32 = 10;

// Cast `a` into the `u64` type. This keeps the same decimal value as there are enough bits to represent it.
let b = a as u64;
</code></pre>
<p><img src="Rust%20theoretical%20concepts%2023a2785fab994b4db7508c6c19feb291/Untitled%202.png" alt="Behavior observed when converting from larger to smaller type (ie. i16—&gt; i8)" /></p>
<p>Behavior observed when converting from larger to smaller type (ie. i16—&gt; i8)</p>
</li>
<li>
<p>Code sharing between files and visibility in Rust projects</p>
<p>Functions are private (not visible) between files.</p>
<p>You can modify the default visibility of an entity using a <strong>visibility modifier</strong>.</p>
<p>Some common visibility modifiers are:</p>
<ul>
<li><code>pub</code>: makes the entity <strong>public</strong>, i.e. accessible from outside the module where it's defined, potentially from
other crates.</li>
<li><code>pub(crate)</code>: makes the entity public within the same <strong>crate</strong>, but not outside of it.</li>
<li><code>pub(super)</code>: makes the entity public within the parent module.</li>
<li><code>pub(in path::to::module)</code>: makes the entity public within the specified module.</li>
</ul>
<p>You can use these modifiers on modules, structs, functions, fields, etc.
For example:</p>
<pre><code class="language-rust">pub struct Configuration {
    pub(crate) version: u32,
    active: bool,
}
</code></pre>
</li>
<li>
<p>Encapsulation</p>
<p>Allows to access struct variables by keeping them private.</p>
<p>This is achieved by writing specific methos on struct which are public.</p>
<pre><code class="language-rust">pub mod ticket {
    pub struct Ticket {
        title: String,
        description: String,
        status: String,
    }

    impl Ticket {
        pub fn new(title: String, description: String, status: String) -&gt; Ticket {
            if title.is_empty() {
                panic!("Title cannot be empty");
            }
            if title.len() &gt; 50 {
                panic!("Title cannot be longer than 50 bytes");
            }
            if description.is_empty() {
                panic!("Description cannot be empty");
            }
            if description.len() &gt; 500 {
                panic!("Description cannot be longer than 500 bytes");
            }
            if status != "To-Do" &amp;&amp; status != "In Progress" &amp;&amp; status != "Done" {
                panic!("Only `To-Do`, `In Progress`, and `Done` statuses are allowed");
            }
        
            Ticket {
                title,
                description,
                status,
            }
        }
        // Add three public methods to the `Ticket` struct. 
        //This allows to acces values by leaving the struct values private
        pub fn title(self) -&gt; String{
            return self.title;
        }

        pub fn description(self)-&gt; String{
            return self.description;
        }

        pub fn status(self)-&gt; String{
            return  self.status;
        }

</code></pre>
</li>
</ul>
